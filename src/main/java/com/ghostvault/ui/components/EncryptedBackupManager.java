package com.ghostvault.ui.components;

import javafx.application.Platform;
import javafx.concurrent.Task;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.stage.DirectoryChooser;
import javafx.stage.FileChooser;
import javafx.stage.Stage;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

/**
 * Encrypted backup and restore functionality
 */
public class EncryptedBackupManager {
    
    private Stage parentStage;
    private NotificationSystem notificationSystem;
    
    private static final String BACKUP_EXTENSION = ".gvbackup";\n    private static final String ALGORITHM = \"AES\";\n    private static final String TRANSFORMATION = \"AES/CBC/PKCS5Padding\";\n    private static final int KEY_LENGTH = 256;\n    private static final int IV_LENGTH = 16;\n    \n    public EncryptedBackupManager(Stage parentStage) {\n        this.parentStage = parentStage;\n        this.notificationSystem = NotificationSystem.getInstance();\n    }\n    \n    /**\n     * Create encrypted backup of vault directory\n     */\n    public void createBackup(File vaultDirectory, String password, Consumer<BackupResult> onComplete) {\n        if (vaultDirectory == null || !vaultDirectory.exists() || !vaultDirectory.isDirectory()) {\n            onComplete.accept(new BackupResult(false, \"Invalid vault directory\"));\n            return;\n        }\n        \n        if (password == null || password.trim().isEmpty()) {\n            onComplete.accept(new BackupResult(false, \"Password is required for backup encryption\"));\n            return;\n        }\n        \n        // Show save dialog for backup file\n        FileChooser fileChooser = new FileChooser();\n        fileChooser.setTitle(\"Save Encrypted Backup\");\n        \n        String timestamp = new SimpleDateFormat(\"yyyyMMdd_HHmmss\").format(new Date());\n        String defaultName = \"GhostVault_Backup_\" + timestamp + BACKUP_EXTENSION;\n        fileChooser.setInitialFileName(defaultName);\n        \n        fileChooser.getExtensionFilters().add(\n            new FileChooser.ExtensionFilter(\"GhostVault Backup Files\", \"*\" + BACKUP_EXTENSION)\n        );\n        \n        File backupFile = fileChooser.showSaveDialog(parentStage);\n        if (backupFile == null) {\n            onComplete.accept(new BackupResult(false, \"Backup cancelled\"));\n            return;\n        }\n        \n        NotificationSystem.ProgressNotification progressNotification = \n            NotificationSystem.showProgress(\"Creating Backup\", \"Preparing encrypted backup...\");\n        \n        Task<BackupResult> backupTask = new Task<BackupResult>() {\n            @Override\n            protected BackupResult call() throws Exception {\n                updateMessage(\"Scanning vault directory...\");\n                \n                // Get list of all files to backup\n                List<File> filesToBackup = getAllFiles(vaultDirectory);\n                updateMessage(\"Found \" + filesToBackup.size() + \" files to backup\");\n                \n                // Create temporary zip file\n                File tempZip = File.createTempFile(\"vault_backup_\", \".zip\");\n                tempZip.deleteOnExit();\n                \n                try {\n                    // Create zip archive\n                    updateMessage(\"Creating archive...\");\n                    createZipArchive(vaultDirectory, filesToBackup, tempZip, this);\n                    \n                    // Encrypt the zip file\n                    updateMessage(\"Encrypting backup...\");\n                    encryptFile(tempZip, backupFile, password);\n                    \n                    // Clean up temp file\n                    tempZip.delete();\n                    \n                    updateProgress(1, 1);\n                    return new BackupResult(true, \"Backup created successfully: \" + backupFile.getName());\n                    \n                } catch (Exception e) {\n                    // Clean up on error\n                    if (tempZip.exists()) {\n                        tempZip.delete();\n                    }\n                    if (backupFile.exists()) {\n                        backupFile.delete();\n                    }\n                    throw e;\n                }\n            }\n            \n            @Override\n            protected void succeeded() {\n                Platform.runLater(() -> {\n                    BackupResult result = getValue();\n                    progressNotification.complete(\"Backup completed\");\n                    NotificationSystem.showSuccess(\"Backup Complete\", result.message);\n                    onComplete.accept(result);\n                });\n            }\n            \n            @Override\n            protected void failed() {\n                Platform.runLater(() -> {\n                    progressNotification.complete(\"Backup failed\");\n                    String errorMsg = \"Backup failed: \" + getException().getMessage();\n                    NotificationSystem.showError(\"Backup Error\", errorMsg);\n                    onComplete.accept(new BackupResult(false, errorMsg));\n                });\n            }\n        };\n        \n        progressNotification.progressProperty().bind(backupTask.progressProperty());\n        progressNotification.messageProperty().bind(backupTask.messageProperty());\n        \n        Thread backupThread = new Thread(backupTask);\n        backupThread.setDaemon(true);\n        backupThread.start();\n    }\n    \n    /**\n     * Restore vault from encrypted backup\n     */\n    public void restoreBackup(File backupFile, String password, File targetDirectory, Consumer<RestoreResult> onComplete) {\n        if (backupFile == null || !backupFile.exists()) {\n            onComplete.accept(new RestoreResult(false, \"Backup file does not exist\"));\n            return;\n        }\n        \n        if (password == null || password.trim().isEmpty()) {\n            onComplete.accept(new RestoreResult(false, \"Password is required for backup decryption\"));\n            return;\n        }\n        \n        if (targetDirectory == null) {\n            onComplete.accept(new RestoreResult(false, \"Target directory is required\"));\n            return;\n        }\n        \n        NotificationSystem.ProgressNotification progressNotification = \n            NotificationSystem.showProgress(\"Restoring Backup\", \"Preparing to restore from backup...\");\n        \n        Task<RestoreResult> restoreTask = new Task<RestoreResult>() {\n            @Override\n            protected RestoreResult call() throws Exception {\n                updateMessage(\"Decrypting backup file...\");\n                \n                // Create temporary decrypted zip file\n                File tempZip = File.createTempFile(\"vault_restore_\", \".zip\");\n                tempZip.deleteOnExit();\n                \n                try {\n                    // Decrypt the backup file\n                    decryptFile(backupFile, tempZip, password);\n                    \n                    // Extract the zip file\n                    updateMessage(\"Extracting files...\");\n                    int extractedCount = extractZipArchive(tempZip, targetDirectory, this);\n                    \n                    // Clean up temp file\n                    tempZip.delete();\n                    \n                    updateProgress(1, 1);\n                    return new RestoreResult(true, \"Restored \" + extractedCount + \" files successfully\");\n                    \n                } catch (Exception e) {\n                    // Clean up on error\n                    if (tempZip.exists()) {\n                        tempZip.delete();\n                    }\n                    throw e;\n                }\n            }\n            \n            @Override\n            protected void succeeded() {\n                Platform.runLater(() -> {\n                    RestoreResult result = getValue();\n                    progressNotification.complete(\"Restore completed\");\n                    NotificationSystem.showSuccess(\"Restore Complete\", result.message);\n                    onComplete.accept(result);\n                });\n            }\n            \n            @Override\n            protected void failed() {\n                Platform.runLater(() -> {\n                    progressNotification.complete(\"Restore failed\");\n                    String errorMsg = \"Restore failed: \" + getException().getMessage();\n                    NotificationSystem.showError(\"Restore Error\", errorMsg);\n                    onComplete.accept(new RestoreResult(false, errorMsg));\n                });\n            }\n        };\n        \n        progressNotification.progressProperty().bind(restoreTask.progressProperty());\n        progressNotification.messageProperty().bind(restoreTask.messageProperty());\n        \n        Thread restoreThread = new Thread(restoreTask);\n        restoreThread.setDaemon(true);\n        restoreThread.start();\n    }\n    \n    /**\n     * Show backup creation dialog\n     */\n    public void showBackupDialog(File vaultDirectory) {\n        Dialog<String> dialog = new Dialog<>();\n        dialog.setTitle(\"Create Encrypted Backup\");\n        dialog.setHeaderText(\"Create an encrypted backup of your vault\");\n        \n        // Create dialog content\n        VBox content = new VBox(15);\n        content.setPadding(new Insets(20));\n        \n        Label infoLabel = new Label(\"Enter a strong password to encrypt your backup:\");\n        \n        PasswordField passwordField = new PasswordField();\n        passwordField.setPromptText(\"Backup password\");\n        \n        PasswordField confirmPasswordField = new PasswordField();\n        confirmPasswordField.setPromptText(\"Confirm password\");\n        \n        Label warningLabel = new Label(\"âš  Keep this password safe! You will need it to restore your backup.\");\n        warningLabel.setStyle(\"-fx-text-fill: #ff6b35; -fx-font-weight: bold;\");\n        \n        content.getChildren().addAll(infoLabel, passwordField, confirmPasswordField, warningLabel);\n        \n        dialog.getDialogPane().setContent(content);\n        \n        // Add buttons\n        ButtonType createButton = new ButtonType(\"Create Backup\", ButtonBar.ButtonData.OK_DONE);\n        ButtonType cancelButton = new ButtonType(\"Cancel\", ButtonBar.ButtonData.CANCEL_CLOSE);\n        dialog.getDialogPane().getButtonTypes().addAll(createButton, cancelButton);\n        \n        // Enable/disable create button based on password validation\n        Button createBtn = (Button) dialog.getDialogPane().lookupButton(createButton);\n        createBtn.setDisable(true);\n        \n        Runnable validatePasswords = () -> {\n            String password = passwordField.getText();\n            String confirm = confirmPasswordField.getText();\n            \n            boolean valid = !password.isEmpty() && password.equals(confirm) && password.length() >= 8;\n            createBtn.setDisable(!valid);\n        };\n        \n        passwordField.textProperty().addListener((obs, oldText, newText) -> validatePasswords.run());\n        confirmPasswordField.textProperty().addListener((obs, oldText, newText) -> validatePasswords.run());\n        \n        dialog.setResultConverter(dialogButton -> {\n            if (dialogButton == createButton) {\n                return passwordField.getText();\n            }\n            return null;\n        });\n        \n        Optional<String> result = dialog.showAndWait();\n        result.ifPresent(password -> {\n            createBackup(vaultDirectory, password, backupResult -> {\n                // Backup completion is handled by the notification system\n            });\n        });\n    }\n    \n    /**\n     * Show restore dialog\n     */\n    public void showRestoreDialog(File targetDirectory) {\n        // First, select backup file\n        FileChooser fileChooser = new FileChooser();\n        fileChooser.setTitle(\"Select Backup File to Restore\");\n        fileChooser.getExtensionFilters().add(\n            new FileChooser.ExtensionFilter(\"GhostVault Backup Files\", \"*\" + BACKUP_EXTENSION)\n        );\n        \n        File backupFile = fileChooser.showOpenDialog(parentStage);\n        if (backupFile == null) {\n            return;\n        }\n        \n        // Then, get password\n        TextInputDialog passwordDialog = new TextInputDialog();\n        passwordDialog.setTitle(\"Restore Backup\");\n        passwordDialog.setHeaderText(\"Enter backup password\");\n        passwordDialog.setContentText(\"Password:\");\n        \n        // Make it a password field\n        TextField textField = passwordDialog.getEditor();\n        PasswordField passwordField = new PasswordField();\n        passwordField.setText(textField.getText());\n        passwordDialog.getDialogPane().setContent(passwordField);\n        \n        Optional<String> passwordResult = passwordDialog.showAndWait();\n        passwordResult.ifPresent(password -> {\n            restoreBackup(backupFile, password, targetDirectory, restoreResult -> {\n                // Restore completion is handled by the notification system\n            });\n        });\n    }\n    \n    private List<File> getAllFiles(File directory) {\n        List<File> files = new ArrayList<>();\n        getAllFilesRecursive(directory, files);\n        return files;\n    }\n    \n    private void getAllFilesRecursive(File directory, List<File> files) {\n        File[] children = directory.listFiles();\n        if (children != null) {\n            for (File child : children) {\n                if (child.isDirectory()) {\n                    getAllFilesRecursive(child, files);\n                } else {\n                    files.add(child);\n                }\n            }\n        }\n    }\n    \n    private void createZipArchive(File baseDirectory, List<File> files, File zipFile, Task<?> task) throws IOException {\n        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile))) {\n            byte[] buffer = new byte[8192];\n            \n            for (int i = 0; i < files.size(); i++) {\n                File file = files.get(i);\n                \n                if (task != null) {\n                    task.updateProgress(i, files.size());\n                    task.updateMessage(\"Adding \" + file.getName() + \" to archive...\");\n                }\n                \n                // Get relative path\n                String relativePath = baseDirectory.toPath().relativize(file.toPath()).toString();\n                \n                ZipEntry entry = new ZipEntry(relativePath);\n                zos.putNextEntry(entry);\n                \n                try (FileInputStream fis = new FileInputStream(file)) {\n                    int length;\n                    while ((length = fis.read(buffer)) > 0) {\n                        zos.write(buffer, 0, length);\n                    }\n                }\n                \n                zos.closeEntry();\n            }\n        }\n    }\n    \n    private int extractZipArchive(File zipFile, File targetDirectory, Task<?> task) throws IOException {\n        int extractedCount = 0;\n        \n        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(zipFile))) {\n            byte[] buffer = new byte[8192];\n            ZipEntry entry;\n            \n            while ((entry = zis.getNextEntry()) != null) {\n                if (task != null) {\n                    task.updateMessage(\"Extracting \" + entry.getName() + \"...\");\n                }\n                \n                File outputFile = new File(targetDirectory, entry.getName());\n                \n                // Create parent directories\n                File parentDir = outputFile.getParentFile();\n                if (parentDir != null && !parentDir.exists()) {\n                    parentDir.mkdirs();\n                }\n                \n                // Extract file\n                try (FileOutputStream fos = new FileOutputStream(outputFile)) {\n                    int length;\n                    while ((length = zis.read(buffer)) > 0) {\n                        fos.write(buffer, 0, length);\n                    }\n                }\n                \n                extractedCount++;\n                zis.closeEntry();\n            }\n        }\n        \n        return extractedCount;\n    }\n    \n    private void encryptFile(File inputFile, File outputFile, String password) throws Exception {\n        // Generate salt and derive key\n        byte[] salt = new byte[16];\n        new SecureRandom().nextBytes(salt);\n        \n        SecretKey key = deriveKeyFromPassword(password, salt);\n        \n        // Generate IV\n        byte[] iv = new byte[IV_LENGTH];\n        new SecureRandom().nextBytes(iv);\n        \n        Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));\n        \n        try (FileInputStream fis = new FileInputStream(inputFile);\n             FileOutputStream fos = new FileOutputStream(outputFile)) {\n            \n            // Write salt and IV to the beginning of the file\n            fos.write(salt);\n            fos.write(iv);\n            \n            // Encrypt and write data\n            byte[] buffer = new byte[8192];\n            int bytesRead;\n            \n            while ((bytesRead = fis.read(buffer)) != -1) {\n                byte[] encrypted = cipher.update(buffer, 0, bytesRead);\n                if (encrypted != null) {\n                    fos.write(encrypted);\n                }\n            }\n            \n            // Write final block\n            byte[] finalBlock = cipher.doFinal();\n            if (finalBlock != null) {\n                fos.write(finalBlock);\n            }\n        }\n    }\n    \n    private void decryptFile(File inputFile, File outputFile, String password) throws Exception {\n        try (FileInputStream fis = new FileInputStream(inputFile);\n             FileOutputStream fos = new FileOutputStream(outputFile)) {\n            \n            // Read salt and IV\n            byte[] salt = new byte[16];\n            byte[] iv = new byte[IV_LENGTH];\n            \n            if (fis.read(salt) != salt.length || fis.read(iv) != iv.length) {\n                throw new IOException(\"Invalid backup file format\");\n            }\n            \n            // Derive key\n            SecretKey key = deriveKeyFromPassword(password, salt);\n            \n            Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n            cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));\n            \n            // Decrypt data\n            byte[] buffer = new byte[8192];\n            int bytesRead;\n            \n            while ((bytesRead = fis.read(buffer)) != -1) {\n                byte[] decrypted = cipher.update(buffer, 0, bytesRead);\n                if (decrypted != null) {\n                    fos.write(decrypted);\n                }\n            }\n            \n            // Write final block\n            byte[] finalBlock = cipher.doFinal();\n            if (finalBlock != null) {\n                fos.write(finalBlock);\n            }\n        }\n    }\n    \n    private SecretKey deriveKeyFromPassword(String password, byte[] salt) throws Exception {\n        // Simple key derivation - in production, use PBKDF2 or similar\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        md.update(password.getBytes(\"UTF-8\"));\n        md.update(salt);\n        byte[] keyBytes = md.digest();\n        \n        return new SecretKeySpec(keyBytes, ALGORITHM);\n    }\n    \n    /**\n     * Backup result class\n     */\n    public static class BackupResult {\n        public final boolean success;\n        public final String message;\n        \n        public BackupResult(boolean success, String message) {\n            this.success = success;\n            this.message = message;\n        }\n    }\n    \n    /**\n     * Restore result class\n     */\n    public static class RestoreResult {\n        public final boolean success;\n        public final String message;\n        \n        public RestoreResult(boolean success, String message) {\n            this.success = success;\n            this.message = message;\n        }\n    }\n}"